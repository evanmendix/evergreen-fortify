# Fortify 自動修復工作流程指令

## 概述
此指令用於自動化修復 Fortify 安全掃描發現的問題。Agent 將按照以下步驟逐一處理每個專案的 Fortify 問題。

## 前置條件
- 確保已完成 README.md 中的環境設定
- 確保所有專案已 clone 到 `專案資料/` 目錄
- 確保 `產出資料/repo拆分報告/` 中有最新的 Fortify 報告拆分結果
- 確保 `產出資料/Issue修復共筆/` 中有可用的解決方案

## 主要工作流程

### 步驟 1: 理解專案結構
1. 閱讀並理解 `README.md` 的內容
2. 熟悉專案目錄結構，特別是：
   - `產出資料/repo拆分報告/` - 各專案的 Fortify 問題拆分報告
   - `產出資料/Issue修復共筆/` - 修復解決方案知識庫
   - `專案資料/` - 各專案的原始碼

### 步驟 2: 遍歷所有專案報告
1. 進入 `產出資料/repo拆分報告/` 目錄
2. 列出所有專案目錄（排除已修復的專案）
3. 對每個專案目錄執行以下處理流程

### 步驟 3: 處理單一專案的 Fortify 問題

#### 3.1 分析專案報告
1. 進入專案報告目錄（例如：`產出資料/repo拆分報告/imc-fortify-result/`），其中imc位置為各系統名稱
2. 列出所有 Fortify 問題檔案（格式：`001_問題名稱.md`）
3. 逐一處理每個問題檔案

#### 3.2 處理單一 Fortify 問題

對於每個問題檔案：

1. **解析問題資訊**
   - 讀取問題檔案內容
   - 提取問題類型（例如：Cross-Site Scripting, SQL Injection）
   - 識別所有 Source 和 Sink 程式碼位置

2. **尋找解決方案**
   - 在 `產出資料/Issue修復共筆/` 中尋找對應的解決方案
   - 優先尋找專屬解法（檔案名包含具體問題類型）
   - 如無專屬解法，尋找通用解法（按嚴重等級分類）

3. **分析每個 Source**
   對於問題中的每個 Source：
   
   a. **定位程式碼**
   - 根據 Source 資訊定位到對應的專案檔案
   - 找到具體的程式碼行

   b. **評估修復可行性**
   - 檢查解決方案是否適用於當前程式碼
   - 分析程式碼上下文，確認修復不會破壞功能
   - 評估修復的複雜度和風險

   c. **執行修復決策**
   - **如果解決方案完全適用**：直接按照解決方案修復
   - **如果需要調整**：基於對程式碼的理解進行適當調整
   - **如果無法確定**：跳過此 Source，記錄原因

4. **問題級別決策**
   - **如果同一問題的所有 Source 都能成功修復**：繼續到提交階段
   - **如果有任何 Source 無法修復**：跳過整個問題，不進行任何修復

#### 3.3 提交修復結果

如果問題的所有 Source 都已成功修復：

1. **切換到專案目錄**
   ```bash
   cd 專案資料/{專案名稱}/
   ```

2. **確認在正確分支**
   ```bash
   git checkout evergreen/fortify
   ```

3. **顯示修復摘要並等待確認**
   - 顯示已修復的問題名稱和修復的檔案清單
   - 顯示修復前後的程式碼差異（如果適用）
   - **暫停執行，等待使用者確認**
   - 詢問：「以上修復是否正確？是否可以提交到 Git？(y/n)」

4. **根據使用者確認結果執行**
   
   **如果使用者確認 (y)**：
   ```bash
   git add .
   git commit -m "[fortify]fix {fortify_issue_name} issues"
   git push origin evergreen/fortify
   ```
   
   **如果使用者拒絕 (n)**：
   - 撤銷所有修復變更：`git checkout .`
   - 記錄為「使用者拒絕修復」
   - 繼續處理下一個問題

### 步驟 4: 記錄處理結果
將詳細的處理結果記錄到 `fortify_auto_fix_results.md` 檔案中。請參考該檔案中的格式進行記錄。

## 修復策略指導原則

### 安全優先原則
1. **只修復有把握的問題**：如果不確定修復方法，寧可跳過
2. **保持功能完整性**：修復不應破壞現有功能
3. **遵循最佳實踐**：使用業界認可的安全修復方法

### 程式碼修復常見模式

#### Cross-Site Scripting (XSS)
- 輸出編碼：使用適當的編碼函數
- 輸入驗證：驗證和清理使用者輸入
- Content Security Policy：設定適當的 CSP 標頭

#### SQL Injection
- 參數化查詢：使用 PreparedStatement 或類似機制
- 輸入驗證：驗證輸入格式和範圍
- 最小權限原則：限制資料庫使用者權限

#### Path Manipulation
- 路徑正規化：使用安全的路徑處理函數
- 白名單驗證：限制可存取的路徑範圍
- 檔案權限檢查：驗證檔案存取權限

### 跳過條件
以下情況應跳過修復：
1. 程式碼邏輯過於複雜，無法確定修復影響
2. 需要大幅重構才能修復
3. 涉及第三方函式庫的問題
4. 修復可能影響核心業務邏輯
5. 缺乏足夠的上下文資訊
6. **Path Manipulation (Critical) 問題**：經團隊確認目前無解，Fortify 無法識別常見的安全修復方法

### 已確認無解的問題類型

#### Path Manipulation (Critical)
**狀態**：目前無解 (2025-08-05 確認)

**問題描述**：
- Fortify 檢測到攻擊者可控制 `File()` 的檔案系統路徑參數
- 允許攻擊者存取或修改受保護的檔案

**已嘗試但失敗的修復方法**：
1. ❌ **LocaleConvertUtilsBean.convert()** - Fortify 不認可此方法為有效的路徑安全化
2. ❌ **白名單檔案名稱驗證** - 使用正則表達式 `^[a-zA-Z0-9._-]+$` 等模式，Fortify 仍報告漏洞
3. ❌ **自定義 safeFileName() 方法** - 包含中文字符的白名單驗證，Fortify 無法追蹤間接驗證
4. ❌ **路徑遍歷檢查** - 明確檢查 `..` 和目錄前綴，Fortify 仍無法識別

**影響專案**：
- `imc` 專案：`IMC702WController.java:455` - `new File(filePath, name)`
- `ina` 專案：`INA722WController.java:219` 等多處 - 10 個程式碼位置

**根本原因**：
- Fortify 對 Path Manipulation 的檢測極其嚴格
- 無法識別自定義的安全驗證方法
- 需要使用 Fortify 明確認可的官方安全 API

**建議處理方式**：
- 暫停修復嘗試，避免無效的程式碼變更
- 聯繫 Fortify 技術支援或資安團隊尋求官方指引
- 等待 Fortify 更新或官方提供有效的修復模式

## 執行注意事項

1. **備份重要性**：修復前確保程式碼已在 Git 中追蹤
2. **測試考量**：修復後應考慮是否需要額外測試
3. **文件更新**：如有必要，更新相關文件
4. **團隊溝通**：重大修復應通知相關開發團隊

## 錯誤處理

1. **Git 操作失敗**：記錄錯誤，跳過當前專案
2. **檔案讀寫錯誤**：記錄錯誤，嘗試下一個檔案
3. **解析錯誤**：記錄問題，跳過當前問題
4. **權限問題**：檢查檔案權限，記錄並跳過

## 完成條件

當滿足以下條件時，認為工作流程完成：
1. 所有專案都已處理（修復或跳過）
2. 所有修復都已提交到 Git
3. 處理結果已記錄到目錄下 `fortify_auto_fix_results.md`
4. 無未處理的錯誤或異常

---

**重要提醒**：此工作流程涉及程式碼修改，請確保在執行前已做好適當的備份和測試準備。
